---
title: "Projet d’Algorithmique : Classification des séries temporelles à l'aide Dynamic Time Wraping"
author: "Sarah Eliko, Fatimah-Zara Aklila , Samira Sonfack"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_depth: '2'
    df_print: paged
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    highlight: tango
    latex_engine: xelatex
geometry: margin=2.5cm
fontsize: 12pt
---

```{r setup, include=FALSE}
# Installer le package depuis GitHub si nécessaire
if (!requireNamespace("ProjetM2Algo", quietly = TRUE)) {
  if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
  remotes::install_github("samirasonfack/ProjetM2Algo/")
}

# Charger le package
library(ProjetM2Algo)
```
\newpage

# Introduction

Le mathématicien Al-Khwarizmi a rédigé de nombreux travaux qui furent traduits au XIIe siècle. C’est d’ailleurs de son nom que provient le mot « algorithme ».
Un algorithme peut être défini comme un enchaînement d’instructions logiques permettant de résoudre un problème. Il constitue la traduction d’un raisonnement en un pseudo-code. Mais dans quelles circonstances construit-on un algorithme, et comment intervient l’algorithmique dans ce processus ? Lorsqu’une problématique nécessite une méthode de calcul efficace, il devient nécessaire d’adopter une démarche algorithmique. L’algorithmique regroupe l’ensemble des méthodes génériques permettant de résoudre des problèmes. Elle s’intéresse aussi à l’étude de la complexité de ces méthodes, c’est-à-dire à leur rapidité, leur efficacité et leur capacité à s’adapter à différents cas. Autrement dit, elle ne se limite pas à la simple écriture d’un algorithme, mais vise à concevoir la meilleure approche possible pour atteindre un résultat fiable et optimisé.
Aujourd’hui, au XXIe siècle, de nombreux mathématiciens et informaticiens ont inventé, amélioré et publié diverses méthodes de résolution. Ces avancées nous permettent de disposer d'outils conceptuels pour résoudre des problèmes complexes.

La résolution d’une problématique passe d’abord par l’évaluation de la complexité du problème, puis par le choix d’une méthode adaptée, d’où l’utilisation de l’algorithmique. Vient ensuite la construction du programme à l’aide de l’algorithme et en utilisant un langage de programmation choisi. Après l’exécution du programme, un résultat concret est obtenu, traduisant la pertinence de la méthode employée.


## Contexte

Une série temporelle est une suite chronologique de valeurs numériques.
Les séries temporelles sont utilisées dans plusieurs domaines, comme en médecine, par exemple pour le suivi d’une constante vitale au cours du temps, ou encore en finance pour le suivi du cours d’une action.
Dans ces deux disciplines, l’analyse de ces séries temporelles peut être cruciale, notamment pour le diagnostic d’une anomalie ou de la détection d’un comportement particulier.
Dans notre cas, nous allons nous intéresser à une méthode permettant de classifier les séries temporelles.
Dans un premier temps, nous allons utiliser deux algorithmes qui vont nous permettre de comparer deux séries entre elles.
Plus précisément, nous allons utiliser l’algorithme DTW, puis une amélioration de cet algorithme appelée FastDTW.
Enfin, nous choisirons le meilleur algorithme pour la classification.



```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Dynamic Time Warping

L’algorithme Dynamic Time Warping (DTW) ou Déformation Temporelle Dynamique, permet de mesurer la similarité entre deux séries temporelles qui peuvent différer en vitesse ou en phase.  

Cette méthode aligne de manière non linéaire deux séquences temporelles pour obtenir la correspondance optimale entre leurs éléments.

Soient deux séries temporelles :
\[
X = (x_1, x_2, \dots, x_n)
\quad \text{et} \quad
Y = (y_1, y_2, \dots, y_m)
\]

On définit la distance D entre deux points correspondants :
\[
D(i,j) = (x_i - y_j)^2
\]

Le but du DTW est de construire une matrice de coût cumulatif \( C \), où chaque élément \( C(i,j) \) représente le coût minimal d’alignement des sous-séquences \( (x_1, \dots, x_i) \) et \( (y_1, \dots, y_j) \).  
Cette matrice est calculée récursivement selon :
\[
C(i,j) =
\begin{cases}
D(1,1), & \text{si } i = 1, j = 1, \\[8pt]
D(i,1) + C(i-1,1), & \text{si } j = 1, i > 1, \\[8pt]
D(1,j) + C(1,j-1), & \text{si } i = 1, j > 1, \\[8pt]
D(i,j) + \min \big( C(i-1,j), \; C(i,j-1), \; C(i-1,j-1) \big), & \text{sinon.}
\end{cases}
\]

L’objectif de la méthode DTW est de trouver le chemin optimal qui minimise la distance totale entre les deux séries temporelles.  

La distance DTW finale est alors donnée par :
\[
DTW(n,m) = \min_{\pi} \sum_{(i,j) \in \pi} D(i,j)
\]
où \( \pi \) désigne l’ensemble des chemins de warping valides reliant les points \((1,1)\) et \((n,m)\).

Dans la pratique, cette distance correspond à la valeur du dernier élément de la matrice de coût cumulatif :
\[
DTW(X,Y) = C(n,m)
\]

## Algorithme du DTW

L’algorithme DTW repose sur la programmation dynamique.  

Il consiste à remplir progressivement la matrice de coût cumulé \( C \).

\begin{verbatim}
Algorithme DTW(x, y):
1. Initialiser D[i,j] = |x_i - y_j|
2. Initialiser C[1,1] = D[1,1]
3. Remplir la première ligne et la première colonne de C
4. Pour i=2..n, j=2..m :
     C[i,j] = D[i,j] + min(C[i-1,j-1], C[i-1,j], C[i,j-1])
5. Rétrotraçage pour obtenir le chemin optimal
6. Retourner C, traceback, path 
\end{verbatim}

Path correspond au chemin optimal. 
La complexité en temps de l’algorithme DTW est de l’ordre de $O(NM)$.




## Exemple d'application

Considérons les deux séries temporelles suivantes :
\[
X = (1, 2, 3, 4)
\quad \text{et} \quad
Y = (1, 1, 2, 3, 5)
\]

Calcul de la matrice de distances locales \( D(i,j) \) :

\[
D =
\begin{bmatrix}
0 & 0 & 1 & 4 & 16 \\
1 & 1 & 0 & 1 & 9 \\
4 & 4 & 1 & 0 & 4 \\
9 & 9 & 4 & 1 & 1 \\
\end{bmatrix}
\]

Calcul de la matrice de coût cumulatif \( C(i,j) \) :

En remplissant la matrice pas à pas, on obtient :

\[
C =
\begin{bmatrix}
0 & 0 & 1 & 5 & 21 \\
1 & 1 & 0 & 1 & 10 \\
5 & 5 & 1 & 0 & 4 \\
14 & 14 & 5 & 1 & 2 \\
\end{bmatrix}
\]

La distance DTW entre \( X \) et \( Y \) est donnée par le dernier élément de la matrice :
\[
DTW(X,Y) = C(4,5) = 2
\]

Cette valeur faible indique que les deux séries sont similaires, même si elles ne sont pas parfaitement alignées temporellement.  

Le DTW a « déformé » le temps pour trouver un alignement optimal entre les points de \( X \) et \( Y \).


```{r}

x <- c(1, 3, 4, 9)
y <- c(1, 3, 7, 8, 9)
dtw_result <- dtw(x, y)
dtw_result
```

Nous cherchons maintenant à retrouver expérimentalement la complexité de l’algorithme DTW.
Lorsque les deux séries ont la même longueur \(n\), le temps d'exécution peut alors s’écrire sous la forme :

\[
T(n) = C \cdot n^2,
\]

où \(C\) est une constante correspondant au coût d’un calcul élémentaire. Cette constante ne dépend pas de \(n\).

Pour analyser la complexité à partir des mesures expérimentales, nous traçons le graphique
en échelle log-log. En prenant le logarithme de l’expression précédente, on obtient :

\[
\log T(n) = \log C + 2 \log n.
\]

Cette équation est de la forme d’une droite,
dont l’ordonnée à l’origine est \(\log C\) et dont la pente vaut \(2\).
Ainsi, si le graphique \(\log(n)\) -- \(\log(T)\) présente une pente
proche de \(2\), cela confirme expérimentalement la complexité quadratique
théorique du DTW.


### Simulation de la complexité

```{r}
# R
res <- simulation_dtw(debut = 10, fin = 500, pas = 10)
res$pente

```

```{r}
# C++
res <- simulation_dtw_rcpp(debut = 10, fin = 1000, pas = 10)
res$pente
```


## Algorithme du DTW avec bande de Sakoe Chiba fixe - Sakoe Chiba Band


L’algorithme de **Sakoe–Chiba** introduit une contrainte locale appelée **bande de Chiba** afin de limiter les déformations autorisées lors du calcul du *Dynamic Time Warping* (DTW). Dans la formulation classique de la DTW, la matrice de coût est entièrement parcourue, ce qui conduit à une complexité temporelle en $O(N^2)$ pour deux signaux de longueur $N$.

Or lorsqu'on applique l'algorithme sur la même série on voit que le chemin optimal correspond à la diagonale et s'en éloigne d'autant plus que les séries diffèrent. La bande de Chiba impose que l’alignement optimal reste à l’intérieur d’une fenêtre de largeur prédéfinie autour de la diagonale principale.Une variante propose une fenêtre mobile sous forme de matrice dde "région":
- pour un point $(i,j)$, seules les cellules telles que  
  \[
  |i - j| \leq \text{radius}
  \]  
  sont considérées ; 
  
  On considèrera ici à **une taille de bande fixe**  **radius** dans toutes les directions. Ainsi, seuls les coûts des cellules situées dans cette zone restreinte sont évalués.

Grâce à cette contrainte, le nombre d’opérations nécessaires est considérablement réduit, faisant passer la complexité temporelle à :

$$
O(N \cdot w)
$$

où $w$ est la demi-largeur de la bande, généralement beaucoup plus petite que $N$.

En limitant les correspondances possibles, l’algorithme améliore non seulement l’efficacité computationnelle, mais également la robustesse de l’alignement, tout en conservant une bonne précision lorsque les signaux ne présentent pas de fortes distorsions temporelles.

```{r}
# Dans votre Rmd ou dans une fonction R :
# Trouver le chemin du fichier installé
path1 <- system.file("extdata", "commodity.csv", package = "ProjetM2Algo")
path2 <- system.file("extdata", "stock.csv", package = "ProjetM2Algo")

# Charger les données de manière fiable
df_stock <- read.csv(path1, header = TRUE)
df_commodity <- read.csv(path2, header = TRUE)

# Converrtir les dates en type Date sous R
df_stock$Date <- as.Date(df_stock$Date)
df_commodity$Date <- as.Date(df_commodity$Date)

X <- df_stock$Close
Y <- df_commodity$Close
```

```{r}
X
```


```{r}
result <- dtw_sakoe_chiba_rcpp(X,Y,radius=1)
result$matrix

```

```{r}

# Récupérer le chemin d'alignement.
# result$path est une liste de vecteurs (i, j).
alignment_list <- result$path 

# Convertir la liste de vecteurs en une matrice N x 2
# Si result$path est vide (séries non alignables), on arrête.
if (length(alignment_list) == 0) {
    stop("Le chemin DTW est vide. Les séries sont trop contraintes ou inalignables.")
}

alignment_matrix <- do.call(rbind, alignment_list)

# CORRECTION CRITIQUE: 
# Le chemin C++ est 0-basé, mais nous l'avons converti en 1-basé pour R dans le C++.
# VÉRIFIEZ votre fonction C++: si elle retourne {i+1, j+1}, ALORS PAS BESOIN de +1 ici.
# Si vous êtes sûr que la sortie C++ est {i, j} (0-basé), utilisez :
# alignment_matrix <- alignment_matrix + 1
# Si la sortie C++ est {i+1, j+1}, nous ne faisons RIEN ici.
# PENDANT LA RÉVISION, nous ASSUMONS que C++ retourne des indices 1-basés.

aligned_X_indices <- alignment_matrix[, 1]
aligned_Y_indices <- alignment_matrix[, 2]

# Assurer que les indices ne dépassent pas la longueur des séries originales
aligned_X <- X[aligned_X_indices]
aligned_Y <- Y[aligned_Y_indices]

# Le temps d'alignement est simplement la longueur du chemin
time_index <- 1:length(aligned_X)

df_aligned <- data.frame(
  Time = time_index,
  Stock = aligned_X,
  Commodity = aligned_Y
)

# =======================================================
# 2. Plot AVANT Alignement (p1)
# =======================================================

len_max <- max(length(X), length(Y))
len_X <- length(X)
len_Y <- length(Y)

df_before <- data.frame(
  Time = 1:len_max,
  # Pour éviter les problèmes de NA si les séries n'ont pas la même longueur initiale
  Stock = c(X, rep(NA, len_max - len_X)),
  Commodity = c(Y, rep(NA, len_max - len_Y))
)

p1 <- ggplot(df_before, aes(x = Time)) +
  # Nous devons forcer ggplot à n'afficher que la partie non-NA des données
  geom_line(aes(y = Stock, color = "Stock")) +
  geom_line(aes(y = Commodity, color = "Commodity")) +
  labs(
    title = "Avant Alignement DTW",
    y = "Rendements Log",
    color = "Série"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Stock" = "blue", "Commodity" = "red"))


# =======================================================
# 3. Plot APRÈS Alignement (p2)
# =======================================================

p2 <- ggplot(df_aligned, aes(x = Time)) +
  geom_line(aes(y = Stock, color = "Stock")) +
  geom_line(aes(y = Commodity, color = "Commodity")) +
  labs(
    title = paste("Après Alignement DTW (Distance:", round(result$DTW_distance, 4), ")"),
    x = paste("Points Alignés (Longueur Chemin: ", length(time_index), ")"),
    y = "Rendements Log",
    color = "Série"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Stock" = "blue", "Commodity" = "red"))

# =======================================================
# 4. Affichage Côté à Côté
# =======================================================

gridExtra::grid.arrange(p1, p2, ncol = 2)
```



### Calcul théorique de complexité


Soit deux séries temporelles de longueur égale $N$.  

Avec **une bande de Chiba de radius $r$** (fenêtre fixe autour de la diagonale), seules les cellules telles que $|i - j| \le r$ sont calculées.  

Chaque ligne de la matrice contient au maximum $2r + 1$ cellules évaluées. La complexité devient donc :

$$
T_{\text{DTW_bande}}(N, r) = O(N \cdot (2r + 1)) \approx O(N \cdot r)
$$

où $r$ est généralement beaucoup plus petit que $N$.  

Ainsi, la réduction de la complexité par rapport au DTW classique est significative, surtout pour de grandes séries temporelles.

---

### Représentation log-log

Pour visualiser la complexité, on peut utiliser une **échelle log-log** :

$$
x = \log(N), \quad y = \log(T(N))
$$

- Pour le **DTW avec bande fixe** :  

$$
y = \log(N \cdot r) = \log(r) + \log(N) \approx \log(N) \quad \text{si $r$ constant}
$$

En pratique :  

Sur un graphique log-log, la **pente de la droite** correspond à l’exposant de $N$. Donc une pente ≈ 1 
 
   



###Simulation de la complexité temporelle

```{r}
n_values <- round(exp(seq(log(50), log(5000), length.out = 15)))
res1 <- simulate_dtw_sakoe_chiba(
      n_values,
      algo_r = dtw_sakoe_chiba,
      algo_rcpp = dtw_sakoe_chiba_rcpp,
      radius = 2,
      plot = TRUE
      )
```

```{r}
# Simulation 2 (Radius = 5)
res2 <- simulate_dtw_sakoe_chiba(
    n_values,
    algo_r = dtw_sakoe_chiba,
    algo_rcpp = dtw_sakoe_chiba_rcpp,
    radius = 5, # Changer le rayon
    plot = TRUE
)
```


```{r}
library(gridExtra)

gridExtra::grid.arrange(
    res1$plot, 
    res2$plot, 
    ncol = 2,
    top = "Comparaison de la Complexité R vs Rcpp sous différentes contraintes"
)
```
```{r}

# Affichage des pentes 
cat(" Pentes de Complexité par Implémentation :\n")
cat("\n* Pente R (Radius 1) : **", round(res1$slope_r, 4), "**")

cat("\n* Pente R (Radius 2) : **", round(res2$slope_r, 4), "**")

cat("\n* Pente Rcpp (Radius 1) : **", round(res1$slope_rcpp, 4), "**")

cat("\n* Pente Rcpp (Radius 2) : **", round(res2$slope_rcpp, 4), "**")

```
On voit conformément au résultat théorique attendu qu'on a une complexité $O(N)$ avec un pente très proche de 1 pour le code Rcpp et légèrement supérieure à 1 en R. On vérifie également que la **complexité varie peu selon le radius** . Les résultats autour de **1.45** pour le code R mettent en évidence les faiblesses de l'interpréteur R qui introduit un temps de calcul supplémentaire qui augmente avec la valeur de N. Rcpp à contrario est compilé et facilite les calculs lourds tels que les boucles imbriquées.











